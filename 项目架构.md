# Athena Trader 项目架构报告（AI理解专用版）
*项目目前运行在新加坡服务器1G1CPU*
*最后更新：2026年1月16日 - 关键修复：幽灵持仓防护、订单簿降级、下单异常捕获*

---

## 1. 项目概览

**项目名称**：Athena Trader (Athena OS v3.0)
**项目类型**：加密货币量化交易系统
**目标交易所**：OKX（主要支持SWAP永续合约）
**架构模式**：事件驱动 + 异步微服务化

### 1.1 核心设计理念
- **事件驱动架构**：所有模块通过EventBus解耦，使用Pub/Sub模式通信
- **异步优先**：基于asyncio和aiohttp的高性能异步设计
- **依赖注入**：组件间松耦合，易于测试和扩展
- **策略分离**：策略只负责交易逻辑，不关心数据源和网络通信
- **风控贯穿**：资金管理、交易前检查、持仓对账等多层风控
- **轻量化优化**：针对1核1G内存环境优化，移除pandas等重型依赖

---

## 2. 系统架构层次

### 2.1 入口层
**main.py**
- 功能：系统启动入口
- 职责：
  1. 配置日志系统
  2. 加载环境变量（.env文件）
  3. 从环境变量加载配置
  4. 初始化引擎
  5. 启动系统并监听退出信号
  6. 优雅退出处理

**配置加载流程**：
```
环境变量 (.env)
    ↓
load_config_from_env()
    ├─ 🔍 调试日志：打印关键环境变量
    ├─ 🔧 修复：清空默认 strategies 列表
    └─ 🔧 修复：修改 ScalperV1 默认值为 SOL 和 10000U
    ↓
配置字典 {
    total_capital: float,
    rest_gateway: {api_key, secret_key, passphrase, use_demo},
    public_ws: {symbol},
    private_ws: {use_demo},
    risk: {max_order_amount, max_frequency},
    strategies: [{id, type, capital, params}]
}
    ↓
Engine(config)
```

---

## 3. 核心模块

### 3.1 Core模块 (src/core/)

#### 3.1.1 Engine (主引擎)
**文件**：engine.py

**核心职责**：
- 系统的指挥官，负责组装所有组件
- 统一生命周期管理（initialize, start, stop）
- 依赖注入容器

**组件初始化顺序**：
1. EventBus（事件总线）
2. OMS组件
3. Gateway组件
4. 风控检查器
5. OrderManager（注入风控）
6. Strategies
7. 事件处理器注册
8. 策略资金分配

**关键方法**：
- `initialize()`: 初始化所有组件
- `start()`: 连接网关，启动策略，进入主循环
- `stop()`: 停止策略，断开网关，优雅退出
- `_load_strategy()`: 动态加载策略（支持scalper_v1）
- `_register_event_handlers()`: 注册事件处理器
- `_allocate_strategy_capitals()`: 分配策略资金

**配置示例**：
```python
{
    'total_capital': 10000.0,
    'sync_threshold_pct': 0.10,
    'sync_cooldown_seconds': 60,
    'position_sync_interval': 30,  # 持仓同步间隔（秒）
    'rest_gateway': {'use_demo': True, 'timeout': 10},
    'public_ws': {'symbol': 'BTC-USDT-SWAP', 'use_demo': True},
    'private_ws': {'use_demo': True},
    'risk': {'max_order_amount': 2000.0, 'max_frequency': 5, 'frequency_window': 1.0},
    'strategies': [...]
}
```

#### 3.1.2 EventBus (事件总线)
**文件**：event_bus.py

**设计原则**：
- 轻量级，零依赖
- 异步设计，支持高并发
- 类型安全，使用标准事件格式
- 解耦模块间依赖

**核心功能**：
- `register(event_type, handler)`: 注册事件处理器
- `unregister(event_type, handler)`: 取消注册
- `put(event)`: 异步发布事件
- `put_nowait(event)`: 非阻塞发布事件
- `start()`: 启动后台处理循环
- `stop()`: 停止并清空队列

**事件处理流程**：
```
Event发布 → Queue (maxsize=10000)
    ↓
后台循环 _process_loop()
    ↓
调用所有注册的处理器
    ↓
处理异常并发布ERROR事件
```

**统计信息**：
- published: 发布总数
- processed: 处理总数
- errors: 错误总数
- queue_size: 队列大小
- handlers: 处理器总数

#### 3.1.3 EventTypes (事件类型)
**文件**：event_types.py

**事件类型**：
- TICK: 行情Tick
- ORDER_SUBMITTED: 订单已提交
- ORDER_UPDATE: 订单状态更新
- ORDER_FILLED: 订单成交
- ORDER_CANCELLED: 订单取消
- POSITION_UPDATE: 持仓更新
- ERROR: 错误事件

---

### 3.2 OMS模块 (src/oms/)

#### 3.2.1 CapitalCommander (资金指挥官)
**文件**：capital_commander.py

**核心职责**：
- 管理总资金池
- 分配策略资金
- 追踪策略盈亏
- 实时更新资金状态
- **管理策略风控配置（RiskProfile）**
- **执行策略级别的风控检查**

**数据结构**：
```python
@dataclass
class StrategyCapital:
    allocated: float  # 分配资金
    used: float       # 已使用资金
    profit: float     # 累计盈亏
    available: float  # 可用资金 = allocated - used + profit
```

**关键方法**：
- `allocate_strategy(strategy_id, amount)`: 分配资金
- `check_buying_power(strategy_id, amount_usdt)`: 检查购买力
- `reserve_capital(strategy_id, amount_usdt)`: 预留资金（下单前）
- `release_capital(strategy_id, amount_usdt)`: 释放资金（撤单后）
- `record_profit(strategy_id, profit_usdt)`: 记录盈亏
- `on_order_filled(event)`: 监听订单成交事件，自动更新资金

**RiskProfile 管理方法**：
- `register_risk_profile(profile: RiskProfile)`: 注册策略风控配置
- `get_strategy_profile(strategy_id: str)`: 获取策略风控配置
- `check_policy_compliance(strategy_id, amount_usdt, entry_price)`: 检查策略风控合规性

**风控检查逻辑**：
1. 策略层风控（RiskProfile）：
   - 策略最大杠杆限制
   - 单笔订单金额限制
2. 全局层风控（RiskConfig）：
   - 全局杠杆上限（3x，最后一道防线）
   - 回撤熔断检查

#### 3.2.2 OrderManager (订单管理器)
**文件**：order_manager.py

**核心职责**：
- 接收策略下单请求
- 风控检查（集成PreTradeCheck）
- 调用Gateway发单
- 追踪订单状态
- 自动撤单

**数据结构**：
```python
@dataclass
class Order:
    order_id: str
    symbol: str
    side: str           # "buy" or "sell"
    order_type: str      # "market", "limit", "ioc"
    size: float
    price: float
    filled_size: float = 0.0
    status: str = "pending"  # pending, live, filled, cancelled, rejected
    strategy_id: str = "default"
    raw: dict = None
```

**关键方法**：
- `submit_order(symbol, side, order_type, size, price, strategy_id)`: 提交订单
- `cancel_order(order_id, symbol)`: 撤销订单
- `cancel_all_orders(symbol)`: 撤销所有订单
- `get_all_orders()`: 获取所有订单（用于测试）
- `on_order_update(event)`: 监听订单更新
- `on_order_filled(event)`: 监听订单成交
- `on_order_cancelled(event)`: 监听订单取消

**订单状态流转**：
```
pending → live → filled/cancelled/rejected
```

#### 3.2.3 PositionManager (持仓管理器)
**文件**：position_manager.py

**核心职责**：
- 实时维护本地持仓状态
- 计算持仓盈亏
- 处理期望持仓与实际持仓的同步（Shadow Ledger逻辑）
- **幽灵单防护**：持仓归零时自动撤销所有挂单
- **定时持仓同步**：防止 WebSocket 事件丢失导致的持仓不同步

**数据结构**：
```python
@dataclass
class Position:
    symbol: str
    side: str           # "long" or "short"
    size: float         # 持仓数量
    entry_price: float  # 开仓均价
    unrealized_pnl: float = 0.0
    leverage: int = 1
    raw: dict = None

    @property
    def signed_size(self) -> float:
        # 有符号持仓大小 (long=正, short=负)
```

**关键方法**：
- `update_from_event(event)`: 根据事件更新持仓
- `_update_position(api_position)`: 从API持仓更新
- `_update_position_from_order(order_filled)`: 从订单成交更新
- `_calculate_pnl(position, current_price)`: 计算盈亏
- `update_target_position(symbol, side, size)`: 更新策略期望持仓
- `_reconcile(api_position)`: 对账逻辑（Shadow Ledger核心）
- `check_sync_needed(symbol)`: 检查是否需要同步
- `cancel_all_stop_loss_orders(symbol)`: 取消所有止损单（幽灵单防护）
- `start_scheduled_sync(interval=30)`: 启动定时持仓同步任务

**对账逻辑（Shadow Ledger）**：
```
1. 获取策略期望持仓: {symbol: {side, size, timestamp}}
2. 获取API实际持仓: {symbol: signed_size}
3. 计算差额: delta = target_signed_size - actual_signed_size
4. 计算偏差百分比: diff_pct = abs(delta) / abs(target_signed_size)
5. 如果 diff_pct > threshold (10%) → 触发同步
6. 冷却时间检查 (60秒)
```

**幽灵单防护逻辑**：
```
1. 监听 POSITION_UPDATE 事件
2. 检测持仓归零 (abs(size) < 0.001)
3. 触发 cancel_all_stop_loss_orders()
4. 撤销所有该交易对的挂单
5. 发布 ORDER_CANCELLED 事件
```

---

### 3.3 网关模块 (src/gateways/)

#### 3.3.1 BaseGateway (基类)
**文件**：base_gateway.py

**抽象方法**：
- `connect()`: 连接网关
- `disconnect()`: 断开网关
- `is_connected()`: 检查连接状态
- `get_balance()`: 获取余额
- `get_positions()`: 获取持仓
- `place_order()`: 下单
- `cancel_order()`: 撤单
- `get_kline()`: 获取K线

#### 3.3.2 OkxRestGateway (OKX REST API)
**文件**：okx/rest_api.py

**关键特性**：
- 持久Session复用（TCP Keep-Alive）
- 自动OKX V5 API签名（使用OkxSigner）
- 完整的异步上下文管理
- 低延迟，高吞吐量
- 统一的K线获取功能
- **支持止损单**：通过conditional订单类型实现stop_market

**核心类**：
```python
class OkxRestGateway(RestGateway):
    def __init__(self, api_key, secret_key, passphrase,
                 base_url="https://www.okx.com",
                 use_demo=False, timeout=10, event_bus=None)
```

**HTTP请求流程**：
```
1. 创建持久化ClientSession
   - limit=100
   - ttl_dns_cache=300
   - keepalive_timeout=30
   - enable_cleanup_closed=True

2. 生成请求头（使用OkxSigner）
   - timestamp: ISO格式
   - sign: HMAC-SHA256签名
   - OK-ACCESS-KEY/PASSPHRASE
   - x-simulated-trading: 1 (模拟模式)

3. 发送HTTP请求
   - GET: /api/v5/account/balance
   - GET: /api/v5/account/positions
   - POST: /api/v5/trade/order
   - POST: /api/v5/trade/cancel-order
   - GET: /api/v5/market/candles
   - POST: /api/v5/account/set-leverage

4. 解析响应
   - 检查HTTP状态码
   - 检查API错误码
   - 发布事件（await publish_event）
```

#### 3.3.3 OkxSigner (签名工具)
**文件**：okx/auth.py

**签名方法**：
```python
sign(timestamp, request_method, request_path, body, secret_key):
    message = timestamp + request_method + request_path + body
    signature = base64.b64encode(
        hmac.new(secret_key.encode('utf-8'),
                message.encode('utf-8'),
                hashlib.sha256).digest()
    ).decode()
```

#### 3.3.4 WebSocket网关
**文件**：
- okx/ws_base.py（WebSocket基类）
- okx/ws_public_gateway.py（公共WebSocket）
- okx/ws_private_gateway.py（私有WebSocket）

**功能**：
- 订阅公共行情（Tick数据）
- 订阅私有数据（订单更新、持仓更新）
- 自动重连机制
- 心跳保活

---

### 3.4 策略模块 (src/strategies/)

#### 3.4.1 BaseStrategy (策略基类)
**文件**：base_strategy.py

**核心设计**：
- 策略只负责交易逻辑，不关心数据源
- 通过事件总线接收市场数据
- 纯粹的策略实现，不包含网络通信
- **支持自带风控配置（RiskProfile）**

**基类接口**：
```python
class BaseStrategy(ABC):
    @abstractmethod
    async def on_tick(self, event: Event):
        """处理Tick事件（策略核心方法）"""
        pass

    @abstractmethod
    async def on_signal(self, signal: Dict[str, Any]):
        """处理策略信号"""
        pass

    async def buy(self, symbol, size, order_type="market", price=None) -> bool
    async def sell(self, symbol, size, order_type="market", price=None) -> bool
    async def start(self)  # 启动策略
    async def stop(self)   # 停止策略
```

**便捷方法**：
- `buy()`: 买入
- `sell()`: 卖出

#### 3.4.2 ScalperV1 (极速剥头皮策略) ⭐
**文件**：hft/scalper_v1.py

**策略逻辑**：
- 基于微观结构失衡（Micro-Imbalance）的超短线剥头皮
- 完全不看K线，只处理on_tick (Trade Stream)
- 极速计算：使用原生Python float累加成交量
- Maker模式：开仓使用限价单，降低手续费，平仓使用市价单
- 动量触发：当1秒内买入量 > 卖出量 * 3 且买入量 > 阈值时，立即限价挂单
- 光速离场：
  - 止盈：+0.2% 立即走人
  - 止损：+5秒不涨立即走人 (Time Stop)

**核心特性**：
- **定时持仓同步**：每30秒从 REST API 同步真实持仓，防止幽灵持仓
- **订单簿降级策略**：订单簿数据不可用时使用 Last Price 作为基准价格
- **下单异常捕获**：所有下单调用都有详细的错误日志和失败处理
- **开仓锁机制**：防止同一信号多次触发下单，避免重复开仓风险
- **Private WebSocket 登录确认**：等待登录成功后再订阅频道
- **Private WebSocket URL 修复**：使用标准模拟盘 URL，避免订阅失败

**配置类**：
```python
@dataclass
class ScalperV1Config:
    symbol: str = "BTC-USDT-SWAP"
    imbalance_ratio: float = 3.0          # 买量 > 卖量 * ratio 才触发
    min_flow_usdt: float = 1000.0        # 最小流速（USDT），过滤杂波
    take_profit_pct: float = 0.002       # 止盈 0.2%
    stop_loss_pct: float = 0.01          # 硬止损 1%
    time_limit_seconds: int = 5          # 时间止损 5 秒
    position_size: Optional[float] = None  # 仓位大小（None=基于风险计算）
    maker_timeout_seconds: float = 2.0    # Maker 挂单超时时间（秒）
    tick_size: float = 0.01              # 最小价格跳动单位（默认 0.01 USDT）
    max_chase_distance_pct: float = 0.001 # 最大追单距离（默认 0.1%）
    enable_chasing: bool = True          # 是否启用追单机制
```

**风控配置**：
```python
RiskProfile(
    strategy_id="scalper_v1",
    max_leverage=5.0,                    # 允许 5 倍杠杆
    stop_loss_type=StopLossType.TIME_BASED, # 时间止损
    time_limit_seconds=5,                  # 5 秒强制平仓
    single_loss_cap_pct=0.02,              # 单笔最大亏损 2%
    max_order_size_usdt=500.0,             # HFT 快进快出，单笔较小
    max_daily_loss_pct=0.05                 # 每日最大亏损 5%
)
```

**核心逻辑**（on_tick）：
```
1. 窗口重置（每秒重置一次，比 deque 快得多）
   - now = time.time()
   - if now - self.vol_window_start >= 1.0:
       self.buy_vol = 0.0
       self.sell_vol = 0.0
       self.vol_window_start = now

2. 累加成交量（只做加法，极快）
   - trade = event.data
   - price = float(trade['price'])
   - size = float(trade['size'])
   - usdt_val = price * size
   - if trade['side'] == 'buy':
       self.buy_vol += usdt_val
   - else:
       self.sell_vol += usdt_val

3. 触发逻辑（仅空仓时检查）
   - if (self.buy_vol > self.sell_vol * self.imbalance_ratio) and \
      (self.buy_vol > self.min_flow_usdt):
       - 立即开仓！
       - await self.buy(...)
```

**统计信息**：
- total_trades: 总交易次数
- win_trades: 盈利次数
- loss_trades: 亏损次数
- win_rate: 胜率
- buy_vol_current: 当前买量
- sell_vol_current: 当前卖量
- imbalance_current: 当前失衡比
- max_imbalance_seen: 最大失衡比

---

### 3.5 风控模块 (src/risk/)

#### 3.5.1 RiskProfile (风控配置文件)
**文件**：config/risk_profile.py

**核心职责**：
- 定义策略级别的风控配置
- 实现策略与风控的解耦
- 支持不同策略类型的差异化风控参数

**数据结构**：
```python
@dataclass
class RiskProfile:
    """策略风控配置文件"""
    strategy_id: str

    # 杠杆限制
    max_leverage: float = 1.0          # 该策略允许的最大真实杠杆

    # 单笔风控
    max_order_size_usdt: float = 1000.0 # 单笔最大名义价值
    single_loss_cap_pct: float = 0.01   # 单笔最大亏损占总资金比例 (1% Rule)

    # 止损模式
    stop_loss_type: StopLossType = StopLossType.HARD_PRICE

    # HFT 特有配置
    time_limit_seconds: int = 0        # 持仓最大时间 (秒), 0为不限制

    # 每日熔断
    max_daily_loss_pct: float = 0.05   # 当日累计亏损超过5%停止该策略

class StopLossType(Enum):
    """止损类型枚举"""
    HARD_PRICE = "hard_price"    # 硬价格止损（传统）
    TIME_BASED = "time_based"    # 时间止损（HFT专用）
    TRAILING = "trailing"        # 移动止损（趋势专用）
```

#### 3.5.2 RiskConfig (风控配置)
**文件**：risk_config.py

**核心职责**：
- 定义全局风控参数
- 机构级资金管理系统的硬性参数配置

**关键配置**：
```python
@dataclass
class RiskConfig:
    # 单笔交易风险控制
    RISK_PER_TRADE_PCT: float = 0.01  # 每笔交易风险不超过总资金的1%

    # 杠杆控制
    MAX_GLOBAL_LEVERAGE: float = 3.0  # 全局真实杠杆上限（绝对红线）

    # 回撤控制
    MAX_DRAWDOWN_LIMIT: float = 0.15  # 策略最大回撤熔断阈值

    # 止损保护
    DEFAULT_STOP_LOSS_PCT: float = 0.02  # 默认止损百分比
    MIN_STOP_DISTANCE_PCT: float = 0.001  # 最小止损价差保护
```

#### 3.5.3 PreTradeCheck (交易前检查)
**文件**：risk/pre_trade.py

**核心职责**：
- 在下单前执行风险检查
- 防止异常交易

**检查项**：
1. **单笔订单金额检查**：
   - 默认阈值：2000 USDT
   - 超过则拒绝

2. **下单频率检查**：
   - 默认限制：1秒内 < 5单
   - 超过则拒绝

---

## 4. 工具模块 (src/utils/)

### 4.1 Logger (日志系统)
**文件**：logger.py
- 支持多级别日志
- 文件日志输出
- 控制台日志输出

### 4.2 Config (配置管理)
**文件**：config.py
- 从环境变量加载配置
- 配置验证
- 默认值处理

### 4.3 Auth (认证工具)
**文件**：auth.py
- API密钥管理
- 签名生成

### 4.4 Cache (缓存)
**文件**：cache.py
- 内存缓存
- Redis缓存支持

### 4.5 Volatility (波动率估算器)
**文件**：volatility.py

**核心职责**：
- 基于EMA的轻量级波动率估算
- 用于HFT策略实时估算波动率
- 完全使用原生Python，无pandas/numpy依赖

**核心类**：
```python
class VolatilityEstimator:
    """波动率估算器（基于EMA的轻量级实现）"""

    def __init__(self, alpha: float = 0.2,
                 initial_price: float = 0.0,
                 min_volatility_floor: float = 0.005):
        # alpha: EMA平滑因子
        # initial_price: 初始价格
        # min_volatility_floor: 波动率下限（防止横盘时杠杆过大）

    def update_volatility(self, current_price: float,
                        previous_close: float = None) -> float:
        """更新波动率估算"""

    def get_volatility(self) -> float:
        """获取当前波动率"""

    def calculate_atr_based_stop(self, entry_price: float,
                               atr_multiplier: float = 2.0,
                               atr: Optional[float] = None) -> float:
        """基于波动率计算止损价"""

    def reset(self):
        """重置波动率估算器"""
```

---

## 5. 配置系统

### 5.1 配置文件结构
```
config/
├── base.json         # 基础配置
├── development.json   # 开发环境
├── docker-daemon.json # Docker配置
├── local.json        # 本地环境
├── production.json    # 生产环境
└── test.json        # 测试环境
```

### 5.2 环境变量
**必需变量**：
- `OKX_API_KEY`: OKX API密钥
- `OKX_SECRET_KEY`: OKX密钥
- `OKX_PASSPHRASE`: OKX密码短语

**可选变量**：
- `TOTAL_CAPITAL`: 总资金（默认10000 USDT）
- `TRADING_SYMBOL`: 交易对（默认BTC-USDT-SWAP）
- `USE_DEMO`: 是否使用模拟交易（默认true）
- `MAX_ORDER_AMOUNT`: 最大单笔订单金额（默认2000 USDT）
- `MAX_FREQUENCY`: 最大下单频率（默认5单/1s）
- `LOG_LEVEL`: 日志级别（默认INFO）

---

## 6. 数据流分析

### 6.1 市场数据流
```
WebSocket公共网关
    ↓ 订阅行情
TICK事件
    ↓ publish()
EventBus队列
    ↓ process_loop()
Strategy.on_tick()
    ↓ 处理逻辑
OrderManager.submit_order()
    ↓ 风控检查
Gateway.place_order()
    ↓ REST API
交易所
```

### 6.2 订单数据流
```
策略下单请求
    ↓
OrderManager.submit_order()
    ↓ 风控检查
OkxRestGateway.place_order()
    ↓ HTTP POST
交易所返回订单ID
    ↓ 本地保存
EventBus.publish(ORDER_SUBMITTED)
    ↓
监听器处理:
  - CapitalCommander: 预留资金
  - OrderManager: 更新状态
```

### 6.3 订单成交流
```
交易所推送成交事件
    ↓ WebSocket私有网关
EventBus.publish(ORDER_FILLED)
    ↓
监听器处理:
  - CapitalCommander: 释放资金/记录盈亏
  - OrderManager: 更新订单状态
  - PositionManager: 更新持仓
```

### 6.4 持仓同步流
```
定期查询持仓（REST API）
    ↓
EventBus.publish(POSITION_UPDATE)
    ↓
PositionManager.update_from_event()
    ↓
对账逻辑 _reconcile()
    ↓
检查期望持仓 vs 实际持仓
    ↓
差异超过阈值？
    ↓ YES
生成同步计划（RESYNC）
    ↓
策略执行同步操作
```

---

## 7. 依赖分析

### 7.1 核心依赖
```
核心框架:
- asyncio: 异步编程（内置）
- aiohttp==3.10.5: HTTP客户端
- websockets==13.1: WebSocket客户端
- python-dotenv==1.0.0: 环境变量管理

验证和配置:
- pydantic==2.8.2: 数据验证
- pydantic-settings==2.4.0: 配置管理

安全:
- cryptography==42.0.8: 加密和签名

测试:
- pytest==7.4.3: 测试框架
- pytest-cov==4.1.0: 覆盖率
- pytest-asyncio==0.21.1: 异步测试
- pytest-mock==3.12.0: Mock工具
```

### 7.2 模块依赖关系
```
main.py
    ↓
Engine (core/engine.py)
    ↓
EventBus (core/event_bus.py)
    ├→ CapitalCommander (oms/capital_commander.py)
    ├→ PositionManager (oms/position_manager.py)
    ├→ OrderManager (oms/order_manager.py)
    │   └→ PreTradeCheck (risk/pre_trade.py)
    ├→ OkxRestGateway (gateways/okx/rest_api.py)
    │   └→ OkxSigner (gateways/okx/auth.py)
    ├→ OkxPublicWsGateway (gateways/okx/ws_public_gateway.py)
    ├→ OkxPrivateWsGateway (gateways/okx/ws_private_gateway.py)
    └→ Strategies
        ├→ BaseStrategy (strategies/base_strategy.py)
        ├→ ScalperV1 (strategies/hft/scalper_v1.py) ⭐ NEW ✅ 无pandas
        └→ DualEMAStrategy (strategies/trend/dual_ema.py) ✅ 无pandas

工具模块:
    ├→ VolatilityEstimator (utils/volatility.py) ⭐ NEW ✅ 无pandas/numpy
```

### 7.3 依赖优化成果
**已移除**：
- ✅ pandas==2.2.3（节省200-300MB内存）

**新增轻量级工具**：
- ✅ utils/volatility.py（完全无pandas/numpy依赖）

---

## 8. 关键技术点

### 8.1 异步编程模型
- **核心框架**: asyncio
- **HTTP客户端**: aiohttp（持久Session复用）
- **WebSocket**: websockets库
- **事件循环**: 统一由Engine管理

### 8.2 事件驱动架构
- **EventBus**: 轻量级Pub/Sub
- **事件队列**: asyncio.Queue (maxsize=10000)
- **事件处理器**: 异步函数，可注册多个
- **错误处理**: 自动捕获并发布ERROR事件

### 8.3 依赖注入
- **组件初始化**: Engine统一管理
- **接口注入**: EventBus, OrderManager, CapitalCommander
- **松耦合**: 模块间通过EventBus通信

### 8.4 风控机制
- **交易前检查**: PreTradeCheck
  - 金额限制
  - 频率限制
- **资金管理**: CapitalCommander
  - 资金分配
  - 购买力检查
  - 盈亏追踪
  - 策略级风控（RiskProfile）
- **持仓对账**: Shadow Ledger
  - 期望持仓 vs 实际持仓
  - 差异阈值触发同步
  - 冷却时间防止频繁同步
- **幽灵单防护**: PositionManager
  - 持仓归零自动撤单
  - 防止止损单"幽灵化"
- **定时持仓同步**: PositionManager
  - 定期从 REST API 获取真实持仓
  - 对比本地持仓与真实持仓
  - 发现不一致时强制更新
  - 防止 WebSocket 事件丢失导致的幽灵持仓

### 8.5 性能优化
- **Session复用**: TCP Keep-Alive
- **连接池**: aiohttp.TCPConnector (limit=100)
- **DNS缓存**: ttl_dns_cache=300
- **异步非阻塞**: 所有IO操作异步化
- **O(1)算法**: ScalperV1使用极简累加器

### 8.6 内存优化（针对1G内存环境）
- **移除pandas**: 节省200-300MB
- **零历史数据**: ScalperV1不存储Ticks
- **原生Python**: 所有HFT策略使用原生Python实现
- **轻量级工具**: VolatilityEstimator无重型依赖

---

## 9. 总结

### 9.1 架构优势
1. **事件驱动**: 模块解耦，易于扩展
2. **异步优先**: 高性能，低延迟
3. **依赖注入**: 松耦合，易测试
4. **多层风控**: 资金、频率、持仓全面保护
5. **策略分离**: 交易逻辑独立，快速迭代
6. **轻量化**: 针对1G内存环境优化

### 9.2 核心特点
- 支持多策略并发运行
- 实时持仓对账（Shadow Ledger）
- 完整的资金管理体系
- 自动化风控机制
- 支持模拟和实盘交易
- **幽灵单防护**：持仓归零自动撤单
- **止损单支持**：通过conditional订单类型实现
- **策略级风控**：RiskProfile差异化配置
- **轻量级依赖**：移除pandas，节省200-300MB内存
- **定时持仓同步**：防止 WebSocket 事件丢失导致的幽灵持仓
- **订单簿降级策略**：订单簿数据不可用时使用 Last Price 作为基准
- **下单异常捕获**：所有下单调用都有详细的错误日志和失败处理
- **开仓锁机制**：防止同一信号多次触发下单，避免重复开仓风险
- **Private WebSocket 登录确认**：等待登录成功后再订阅频道
- **Private WebSocket URL 修复**：使用标准模拟盘 URL，避免订阅失败

### 9.3 技术栈
- Python 3.x
- asyncio + aiohttp
- OKX V5 API
- pytest测试框架
- Docker部署支持
- **原生Python优先**：HFT策略无重型依赖

### 9.4 可用策略
| 策略 | 状态 | 依赖 | 风控风格 |
|------|------|------|-----------|
| **ScalperV1** | ✅ 可用 | ✅ 无pandas/numpy | HFT（5x杠杆，时间止损）|

---

**报告生成时间**: 2026年1月16日
**项目版本**: Athena OS v3.0
**适用对象**: AI理解和架构分析
**环境要求**: 1核 1G 内存，1ms 延迟
